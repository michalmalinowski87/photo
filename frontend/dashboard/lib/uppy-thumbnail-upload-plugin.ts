import Uppy, { BasePlugin } from "@uppy/core";
import imageCompression from "browser-image-compression";

import api from "./api-service";
import { getWatermarkConfig, type WatermarkConfig } from "./watermark-resolver";
import { applyWatermark, applyFullCoverWatermark } from "./watermark-utils";

/**
 * Custom Uppy plugin to upload three-tier optimized images to S3
 *
 * This plugin generates three versions of each image:
 * 1. Thumbnail (500px, maintain ratio, quality 0.9): Generated using browser-image-compression
 * 2. BigThumb (800px, maintain ratio, quality 0.9): Uses browser-image-compression library
 * 3. Preview (2800px, maintain ratio): Uses browser-image-compression library (adaptive quality)
 *
 * All versions are converted to WebP format and uploaded to S3 using presigned URLs.
 *
 * Three-Tier Optimization Strategy:
 * - Thumbnail (500px, maintain ratio, quality 0.9)
 *   - Use case: CMS grid views, admin panels, dashboard thumbnails
 *   - Generated by: browser-image-compression with fixed quality 0.9
 *   - No optimization target to prevent double compression or over-compression
 *   - Does not upscale images smaller than 500px
 *
 * - BigThumb (800px, maintain ratio, quality 0.9)
 *   - Use case: Masonry/responsive grid layouts in client gallery
 *   - Generated by: browser-image-compression with fixed quality 0.9
 *   - No optimization target to prevent double compression or over-compression
 *   - Does not upscale images smaller than 800px
 *
 * - Preview (2800px, maintain ratio, adaptive quality 0.85-0.92): ~1.6-2.4MB
 *   - Use case: Full-screen quality preview for picky choosers
 *   - Generated by: browser-image-compression with adaptive quality
 *   - Quality adjusts based on original file size to hit target ranges
 *   - Near-lossless quality for professional review
 *   - 2x quality improvement from previous 1400px version
 *
 * Why this approach:
 * - browser-image-compression: Better than raw Canvas API (simpler, more reliable, handles EXIF)
 * - Consistent quality across all image sizes
 * - Custom thumbnail generation ensures high quality dashboard thumbnails
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
interface UppyFileWithMeta {
  meta?: {
    thumbnailPreview?: string;
    thumbnailBlob?: Blob;
    presignedData?: {
      previewUrl?: string;
      bigThumbUrl?: string;
      thumbnailUrl?: string;
    };
    [key: string]: unknown;
  };
  preview?: string;
  data?: File | Blob;
  type?: string;
  [key: string]: unknown;
}

interface UploadError extends Error {
  status?: number;
  code?: string;
  message: string;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export class ThumbnailUploadPlugin extends BasePlugin<any, any, any> {
  static VERSION = "1.0.0";

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(uppy: Uppy, opts: Record<string, unknown>) {
    super(uppy, opts);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    this.id = "thumbnail-upload";
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    this.type = "modifier";
  }

  override install() {
    // Listen for upload completion to upload preview, bigThumb, and thumbnail
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
    (this.uppy as Uppy).on("upload-success", this.handleUploadSuccess.bind(this));
  }

  override uninstall() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/unbound-method
    (this.uppy as Uppy).off("upload-success", this.handleUploadSuccess);
  }

  /**
   * Calculate adaptive quality based on original file size
   * Adjusts quality to better hit target file size ranges while maintaining quality priority
   *
   * Strategy:
   * - Very large originals (>20MB): More aggressive compression
   * - Large originals (10-20MB): Reduce quality to hit size targets
   * - Medium originals (2-10MB): Use standard quality
   * - Small originals (<2MB): Maintain quality (already small files)
   *
   * @param fileSizeMB - Original file size in MB
   * @returns Quality value between 0.85-0.92
   */
  private calculateAdaptiveQuality(fileSizeMB: number): number {
    // Preview quality ranges: 0.85-0.92
    // Target: 0.8-1.2MB per preview
    if (fileSizeMB > 20) {
      // Very large originals: more aggressive compression
      return 0.85;
    } else if (fileSizeMB > 10) {
      // Large originals: reduce quality to hit size target
      return 0.88;
    } else if (fileSizeMB >= 2) {
      // Medium originals: use standard quality
      return 0.9;
    } else {
      // Small originals: maintain quality (already small files)
      return 0.92;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async handleUploadSuccess(file: any) {
    const fileWithMeta = file as UppyFileWithMeta;
    // Only process image files
    if (!fileWithMeta.type?.startsWith("image/")) {
      return;
    }

    // Get presigned URLs from file metadata (set during getUploadParameters)
    const presignedData = fileWithMeta.meta?.presignedData;

    if (!presignedData?.previewUrl || !presignedData?.bigThumbUrl || !presignedData?.thumbnailUrl) {
      return;
    }

    try {
      // Get gallery ID from file metadata
      const galleryId = fileWithMeta.meta?.galleryId as string | undefined;

      // Fetch gallery and business info for watermark resolution
      let watermarkConfig: WatermarkConfig | null = null;
      if (galleryId) {
        try {
          const [gallery, businessInfo] = await Promise.all([
            api.galleries.get(galleryId).catch(() => null),
            api.auth.getBusinessInfo().catch(() => null),
          ]);
          watermarkConfig = getWatermarkConfig(gallery, businessInfo);
        } catch {
          // If watermark config fetch fails, continue without watermark
          watermarkConfig = null;
        }
      }

      // Generate all three versions in parallel for efficiency
      const [preview, bigThumb, thumbnailBlob] = await Promise.all([
        // Preview (2800px) - for full-screen quality viewing (adaptive quality, 2x quality)
        this.generatePreview(fileWithMeta, 2800),
        // BigThumb (800px) - for masonry/responsive grid layouts (quality 0.9)
        this.generateBigThumb(fileWithMeta),
        // Thumbnail (500px) - for dashboard thumbnails (quality 0.9)
        this.generateThumbnail(fileWithMeta),
      ]);

      if (!preview || !bigThumb || !thumbnailBlob) {
        return;
      }

      // Apply watermarks only if explicitly configured.
      // If watermarkConfig is null, no watermark is applied (respecting user's choice to not use watermarks).
      // Preview: watermarked when configured. Thumb/bigThumb: only when watermarkThumbnails is true (one full-cover watermark).
      let finalPreview = preview;
      let finalBigThumb = bigThumb;
      let finalThumbnail = thumbnailBlob;

      if (watermarkConfig?.url) {
        const watermarkThumbnails = watermarkConfig.watermarkThumbnails ?? false;
        try {
          const opacity = watermarkConfig.opacity ?? 0.7;
          finalPreview = await applyWatermark(preview, watermarkConfig.url, opacity);
          if (watermarkThumbnails) {
            [finalBigThumb, finalThumbnail] = await Promise.all([
              applyFullCoverWatermark(bigThumb, watermarkConfig.url, opacity),
              applyFullCoverWatermark(thumbnailBlob, watermarkConfig.url, opacity),
            ]);
          }
        } catch (error) {
          console.error("Failed to apply watermark:", error);
        }
      }

      // Upload all three versions to S3 in parallel with retry logic
      await Promise.all([
        this.uploadToS3WithRetry(presignedData.previewUrl, finalPreview, "image/webp", "preview"),
        this.uploadToS3WithRetry(
          presignedData.bigThumbUrl,
          finalBigThumb,
          "image/webp",
          "bigthumb"
        ),
        this.uploadToS3WithRetry(presignedData.thumbnailUrl, finalThumbnail, "image/webp", "thumb"),
      ]);
    } catch (_error) {
      // Don't fail the upload if thumbnail upload fails
      // eslint-disable-next-line no-console
      console.error("Thumbnail generation/upload failed:", _error);
    }
  }

  /**
   * Generate thumbnail (500px, maintain ratio) from image using browser-image-compression
   * For dashboard thumbnails and CMS grid views
   *
   * Uses fixed quality 0.9 for consistent compression. No optimization target to prevent
   * double compression or over-compression. Does not upscale images smaller than 500px.
   * Maintains aspect ratio (not square cropped).
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async generateThumbnail(file: any): Promise<Blob | null> {
    const fileWithMeta = file as UppyFileWithMeta;
    if (!fileWithMeta.data || !(fileWithMeta.data instanceof File)) {
      return null;
    }

    try {
      // Resize to fit within 500px while maintaining aspect ratio
      // Quality 0.9 for consistent compression, no maxSizeMB to prevent double compression
      // browser-image-compression does not upscale by default
      const compressedFile = await imageCompression(fileWithMeta.data, {
        maxWidthOrHeight: 500, // Fit inside 500px, maintain aspect ratio, no upscaling
        useWebWorker: false,
        fileType: "image/webp",
        initialQuality: 0.9, // Fixed quality 0.9
      });

      return compressedFile;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Upload blob to S3 using presigned URL with retry logic
   */
  private async uploadToS3WithRetry(
    presignedUrl: string,
    blob: Blob,
    contentType: string,
    sizeType: "preview" | "bigthumb" | "thumb",
    maxRetries: number = 3
  ): Promise<void> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        await this.uploadToS3(presignedUrl, blob, contentType);
        // Success - return immediately
        return;
      } catch (error: unknown) {
        const uploadError = error as UploadError;
        lastError = uploadError instanceof Error ? uploadError : new Error(String(uploadError));

        // Don't retry on 403/404 errors (permission/not found)
        if (uploadError?.status === 403 || uploadError?.status === 404) {
          console.warn(
            `[ThumbnailUpload] ${sizeType} upload failed with ${uploadError.status}, not retrying`
          );
          throw uploadError;
        }

        // Retry on network errors, timeouts, or 5xx errors
        const isRetryable =
          uploadError?.code === "ECONNRESET" ||
          uploadError?.code === "ETIMEDOUT" ||
          uploadError?.code === "ENOTFOUND" ||
          (uploadError?.message?.includes("timeout") ?? false) ||
          (uploadError?.message?.includes("network") ?? false) ||
          (uploadError?.status !== undefined && uploadError.status >= 500 && uploadError.status < 600);

        if (!isRetryable || attempt === maxRetries - 1) {
          // Last attempt or non-retryable error
          console.error(
            `[ThumbnailUpload] ${sizeType} upload failed after ${attempt + 1} attempts:`,
            uploadError
          );
          throw uploadError;
        }

        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt) * 1000;
        console.warn(
          `[ThumbnailUpload] ${sizeType} upload failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }

    // Should never reach here, but TypeScript needs it
    if (lastError) {
      throw lastError;
    }
  }

  /**
   * Upload blob to S3 using presigned URL
   */
  private async uploadToS3(presignedUrl: string, blob: Blob, contentType: string): Promise<void> {
    try {
      const response = await fetch(presignedUrl, {
        method: "PUT",
        body: blob,
        headers: {
          "Content-Type": contentType,
        },
      });

      if (!response.ok) {
        const error: UploadError = new Error(
          `Failed to upload to S3: ${response.status} ${response.statusText}`
        ) as UploadError;
        error.status = response.status;
        throw error;
      }
    } catch (error: unknown) {
      // Preserve error properties for retry logic
      const err = error as UploadError;
      if (err.name === "TypeError" && err.message?.includes("fetch")) {
        // Network error - wrap it
        const networkError: UploadError = new Error(`Network error: ${err.message}`) as UploadError;
        networkError.code = "ENOTFOUND";
        throw networkError;
      }
      throw err;
    }
  }

  /**
   * Generate preview (2800px) from image using browser-image-compression
   * For full-screen quality viewing on desktop, 8K TV, and high-resolution displays
   *
   * Uses adaptive quality based on original file size to better hit target file size ranges
   * while maintaining quality priority for client selection.
   *
   * browser-image-compression is better than raw Canvas API because:
   * - Handles EXIF orientation automatically
   * - Better memory management
   * - Handles edge cases (very large images, etc.)
   * - Simpler API
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async generatePreview(file: any, maxWidthOrHeight: number = 2800): Promise<Blob | null> {
    const fileWithMeta = file as UppyFileWithMeta;
    if (!fileWithMeta.data || !(fileWithMeta.data instanceof File)) {
      return null;
    }

    try {
      // Calculate adaptive quality based on original file size
      const fileSizeMB = fileWithMeta.data.size / (1024 * 1024);
      const quality = this.calculateAdaptiveQuality(fileSizeMB);

      // Use browser-image-compression to generate 2800px preview (2x quality improvement)
      // Optimized for full-screen quality viewing:
      // - 2800px: Perfect for desktop, 8K TV, and high-resolution displays (2x from 1400px)
      // - Adaptive quality (0.85-0.92): Adjusts based on original size to hit target
      //   Target: ~1.6-2.4MB per preview (adjusted for 2x size)
      // - Maintains aspect ratio (not square like thumbnail)
      const compressedFile = await imageCompression(fileWithMeta.data, {
        maxSizeMB: 10, // Increased limit for 2800px preview
        maxWidthOrHeight, // Fit inside 2800px, maintain aspect ratio
        useWebWorker: false, // Simpler, works everywhere
        fileType: "image/webp", // Convert to WebP
        initialQuality: quality, // Adaptive quality - excellent for professional review
      });

      return compressedFile;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Generate BigThumb (800px) from image using browser-image-compression
   * For masonry/responsive grid layouts in client gallery
   *
   * Uses fixed quality 0.9 for consistent compression. No optimization target to prevent
   * double compression or over-compression. Does not upscale images smaller than 800px.
   * Maintains aspect ratio (not square cropped).
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async generateBigThumb(file: any): Promise<Blob | null> {
    const fileWithMeta = file as UppyFileWithMeta;
    if (!fileWithMeta.data || !(fileWithMeta.data instanceof File)) {
      return null;
    }

    try {
      // Resize to fit within 800px while maintaining aspect ratio
      // Quality 0.9 for consistent compression, no maxSizeMB to prevent double compression
      // browser-image-compression does not upscale by default
      const compressedFile = await imageCompression(fileWithMeta.data, {
        maxWidthOrHeight: 800, // Fit inside 800px, maintain aspect ratio, no upscaling
        useWebWorker: false,
        fileType: "image/webp",
        initialQuality: 0.9, // Fixed quality 0.9
      });

      return compressedFile;
    } catch (_error) {
      return null;
    }
  }
}
