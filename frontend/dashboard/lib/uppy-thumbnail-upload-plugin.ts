import Uppy, { BasePlugin } from "@uppy/core";
import imageCompression from "browser-image-compression";

/**
 * Custom Uppy plugin to upload three-tier optimized images to S3
 *
 * This plugin generates three versions of each image:
 * 1. Thumbnail (300x300, square): Uses Uppy's ThumbnailGenerator (via thumbnail:generated event)
 * 2. BigThumb (600px, maintain ratio): Uses browser-image-compression library
 * 3. Preview (1400px, maintain ratio): Uses browser-image-compression library
 *
 * All versions are converted to WebP format and uploaded to S3 using presigned URLs.
 *
 * Three-Tier Optimization Strategy (Adaptive Quality):
 * - Thumbnail (300x300, square, quality 80, adaptive if >20KB): ~14KB
 *   - Use case: CMS grid views, admin panels
 *   - Generated by: Uppy's ThumbnailGenerator (optimized for square thumbnails)
 *   - Adaptive: Re-compresses if exceeds 20KB for large originals
 *
 * - BigThumb (600px, maintain ratio, adaptive quality 0.85-0.90): ~80-120KB
 *   - Use case: Masonry/responsive grid layouts in client gallery
 *   - Generated by: browser-image-compression with adaptive quality
 *   - Quality adjusts based on original file size to hit target ranges
 *   - Perfect for beautiful gallery layouts on all devices
 *
 * - Preview (1400px, maintain ratio, adaptive quality 0.88-0.92): ~0.8-1.2MB
 *   - Use case: Full-screen quality preview for picky choosers
 *   - Generated by: browser-image-compression with adaptive quality
 *   - Quality adjusts based on original file size to hit target ranges
 *   - Near-lossless quality for professional review
 *
 * Why this approach:
 * - Uppy's ThumbnailGenerator: Best for square 300px thumbnails (uses Canvas API internally, optimized)
 * - browser-image-compression: Better than raw Canvas API for larger images (simpler, more reliable, handles EXIF)
 * - Both use Canvas API under the hood, but these libraries handle edge cases better
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
interface UppyFileWithMeta {
  meta?: {
    thumbnailPreview?: string;
    thumbnailBlob?: Blob;
    presignedData?: {
      previewUrl?: string;
      bigThumbUrl?: string;
      thumbnailUrl?: string;
    };
    [key: string]: unknown;
  };
  preview?: string;
  data?: File | Blob;
  type?: string;
  [key: string]: unknown;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export class ThumbnailUploadPlugin extends BasePlugin<any, any, any> {
  static VERSION = "1.0.0";

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(uppy: Uppy, opts: Record<string, unknown>) {
    super(uppy, opts);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    this.id = "thumbnail-upload";
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    this.type = "modifier";
  }

  override install() {
    // Listen for thumbnail generation event from Uppy's ThumbnailGenerator
    // We don't need to access the plugin directly - just listen to its events
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
    (this.uppy as Uppy).on("thumbnail:generated", this.handleThumbnailGenerated.bind(this));

    // Also listen for upload completion to upload preview (1200px) and ensure thumbnail is uploaded
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
    (this.uppy as Uppy).on("upload-success", this.handleUploadSuccess.bind(this));
  }

  override uninstall() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/unbound-method
    (this.uppy as Uppy).off("thumbnail:generated", this.handleThumbnailGenerated);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/unbound-method
    (this.uppy as Uppy).off("upload-success", this.handleUploadSuccess);
  }

  /**
   * Calculate adaptive quality based on original file size
   * Adjusts quality to better hit target file size ranges while maintaining quality priority
   *
   * Strategy:
   * - Very large originals (>20MB): More aggressive compression
   * - Large originals (10-20MB): Reduce quality to hit size targets
   * - Medium originals (2-10MB): Use standard quality
   * - Small originals (<2MB): Maintain quality (already small files)
   *
   * @param fileSizeMB - Original file size in MB
   * @param type - Image type: 'preview' or 'bigthumb'
   * @returns Quality value between 0.80-0.92
   */
  private calculateAdaptiveQuality(fileSizeMB: number, type: "preview" | "bigthumb"): number {
    if (type === "preview") {
      // Preview quality ranges: 0.85-0.92
      // Target: 0.8-1.2MB per preview
      if (fileSizeMB > 20) {
        // Very large originals: more aggressive compression
        return 0.85;
      } else if (fileSizeMB > 10) {
        // Large originals: reduce quality to hit size target
        return 0.88;
      } else if (fileSizeMB >= 2) {
        // Medium originals: use standard quality
        return 0.9;
      } else {
        // Small originals: maintain quality (already small files)
        return 0.92;
      }
    } else {
      // BigThumb quality ranges: 0.76-0.90
      // Target: 80-120KB per BigThumb, balance between quality and size
      if (fileSizeMB > 20) {
        // Very large originals: balanced compression (between 0.75 and 0.77)
        // Aim for ~100-120KB to match quality of smaller files
        return 0.76;
      } else if (fileSizeMB > 10) {
        // Large originals: reduce quality to hit size target
        return 0.82;
      } else if (fileSizeMB >= 2) {
        // Medium originals: use standard quality
        return 0.88;
      } else {
        // Small originals: maintain quality (already small files)
        return 0.9;
      }
    }
  }

  /**
   * Convert Blob to data URL asynchronously
   * This allows us to cache data URLs instead of blob URLs, avoiding fetch() calls
   */
  private blobToDataURL(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  /**
   * Handle when Uppy's ThumbnailGenerator creates a thumbnail
   * This gives us the 300px thumbnail that we can use directly
   * Event signature: thumbnail:generated(file, preview)
   * If Uppy gives us a blob URL, we convert it to a data URL immediately to avoid future fetch() calls
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async handleThumbnailGenerated(file: any, preview: string) {
    const fileWithMeta = file as UppyFileWithMeta;
    fileWithMeta.meta ??= {};

    // If Uppy gave us a blob URL, convert it to a data URL immediately
    // This way we avoid fetch() calls later when we need the blob
    if (preview.startsWith("blob:")) {
      try {
        // Fetch once and convert to data URL
        const response = await fetch(preview);
        const blob = await response.blob();
        const dataURL = await this.blobToDataURL(blob);

        // Store as data URL for future use (no more fetch() needed!)
        fileWithMeta.meta.thumbnailPreview = dataURL;

        // Also cache the blob so we don't need to convert again
        fileWithMeta.meta.thumbnailBlob = blob;
      } catch (_error) {
        fileWithMeta.meta.thumbnailPreview = preview;
      }
    } else {
      // It's already a data URL - perfect!
      fileWithMeta.meta.thumbnailPreview = preview;
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async handleUploadSuccess(file: any) {
    const fileWithMeta = file as UppyFileWithMeta;
    // Only process image files
    if (!fileWithMeta.type?.startsWith("image/")) {
      return;
    }

    // Get presigned URLs from file metadata (set during getUploadParameters)
    const presignedData = fileWithMeta.meta?.presignedData;

    if (!presignedData?.previewUrl || !presignedData?.bigThumbUrl || !presignedData?.thumbnailUrl) {
      return;
    }

    try {
      // Calculate file size in MB for adaptive quality
      const fileSizeMB =
        fileWithMeta.data && fileWithMeta.data instanceof File
          ? fileWithMeta.data.size / (1024 * 1024)
          : 5; // Default to medium if size unknown

      // Generate all three versions in parallel for efficiency
      const [preview, bigThumb, thumbnailBlob] = await Promise.all([
        // Preview (1400px) - for full-screen quality viewing (adaptive quality)
        this.generatePreview(fileWithMeta, 1400),
        // BigThumb (600px) - for masonry/responsive grid layouts (adaptive quality)
        this.generateBigThumb(fileWithMeta, 600),
        // Thumbnail (300x300) - from Uppy's ThumbnailGenerator
        this.getThumbnailBlob(fileWithMeta, fileSizeMB),
      ]);

      if (!preview || !bigThumb || !thumbnailBlob) {
        return;
      }

      // Upload all three versions to S3 in parallel
      await Promise.all([
        this.uploadToS3(presignedData.previewUrl, preview, "image/webp"),
        this.uploadToS3(presignedData.bigThumbUrl, bigThumb, "image/webp"),
        this.uploadToS3(presignedData.thumbnailUrl, thumbnailBlob, "image/webp"),
      ]);
    } catch (_error) {
      // Don't fail the upload if thumbnail upload fails
      // eslint-disable-next-line no-console
    }
  }

  /**
   * Convert data URL to Blob synchronously (no fetch needed)
   * This is much more efficient than using fetch() which triggers network requests
   */
  private dataURLtoBlob(dataURL: string): Blob {
    const arr = dataURL.split(",");
    const mime = arr[0]?.match(/:(.*?);/)?.[1] ?? "image/webp";
    const bstr = atob(arr[1] ?? "");
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
  }

  /**
   * Get the thumbnail blob from Uppy's generated thumbnail
   * The thumbnail was generated by ThumbnailGenerator and stored in file.preview
   * Since we configured thumbnailType: 'image/webp', it should already be WebP
   * Caches the blob in file.meta to avoid re-converting on every access
   *
   * If thumbnail exceeds 20KB target, applies additional compression pass
   *
   * @param fileSizeMB - Original file size in MB (for adaptive compression if needed)
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async getThumbnailBlob(file: any, fileSizeMB?: number): Promise<Blob | null> {
    try {
      const fileWithMeta = file as UppyFileWithMeta;
      // Check if we already cached the blob (avoid re-converting)
      if (fileWithMeta.meta?.thumbnailBlob && fileWithMeta.meta.thumbnailBlob instanceof Blob) {
        const cachedBlob = fileWithMeta.meta.thumbnailBlob;
        // Check if cached blob exceeds size target and needs re-compression
        const sizeKB = cachedBlob.size / 1024;
        if (sizeKB > 20 && fileSizeMB) {
          // Thumbnail exceeds target - apply additional compression
          // Apply to all sizes, but more aggressive for larger originals
          return await this.optimizeThumbnailSize(cachedBlob, fileSizeMB);
        }
        return cachedBlob;
      }

      // Uppy's ThumbnailGenerator stores the 300px thumbnail in file.preview (data URL)
      // The preview property contains the data URL of the generated thumbnail
      const thumbnailPreview = fileWithMeta.preview ?? fileWithMeta.meta?.thumbnailPreview;

      if (!thumbnailPreview || typeof thumbnailPreview !== "string") {
        return null;
      }

      let blob: Blob;

      // At this point, thumbnailPreview should always be a data URL
      // because we converted blob URLs to data URLs in handleThumbnailGenerated()
      // If it's still a blob URL (shouldn't happen), fetch it but log a warning
      if (thumbnailPreview.startsWith("data:")) {
        // Convert data URL directly to blob WITHOUT fetch (no network request!)
        blob = this.dataURLtoBlob(thumbnailPreview);
      } else if (thumbnailPreview.startsWith("blob:")) {
        // This shouldn't happen if handleThumbnailGenerated() ran correctly
        const response = await fetch(thumbnailPreview);
        blob = await response.blob();
        // Convert to data URL for future use
        const dataURL = await this.blobToDataURL(blob);
        fileWithMeta.meta ??= {};
        fileWithMeta.meta.thumbnailPreview = dataURL;
      } else {
        throw new Error(
          `Unexpected thumbnail preview format: ${thumbnailPreview.substring(0, 20)}...`
        );
      }

      // Since we configured thumbnailType: 'image/webp', it should already be WebP
      // But verify and convert if needed
      if (blob.type !== "image/webp") {
        blob = await this.convertToWebP(blob, 300, 0.8);
      }

      // Check if thumbnail exceeds size target (20KB) and needs optimization
      const sizeKB = blob.size / 1024;
      if (sizeKB > 20 && fileSizeMB) {
        // Thumbnail exceeds target - apply additional compression
        // Apply to all sizes, but more aggressive for larger originals
        blob = await this.optimizeThumbnailSize(blob, fileSizeMB);
      }

      // Cache the blob to avoid re-converting
      fileWithMeta.meta ??= {};
      fileWithMeta.meta.thumbnailBlob = blob;

      return blob;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Optimize thumbnail size if it exceeds 20KB target
   * Applies additional compression pass for large originals
   *
   * @param blob - Thumbnail blob to optimize
   * @param fileSizeMB - Original file size in MB
   * @returns Optimized thumbnail blob
   */
  private async optimizeThumbnailSize(blob: Blob, fileSizeMB: number): Promise<Blob> {
    try {
      // For large originals, use lower quality to hit size target
      // Quality range: 0.57-0.75 (lower than preview/bigthumb since thumbnails are smaller)
      // Target: ~14-16KB per thumbnail, similar quality to 11.6MB files
      let quality: number;
      if (fileSizeMB > 20) {
        // Very large originals: balanced compression (between 0.55 and 0.60)
        // Aim for ~14-16KB to match quality of 11.6MB files
        quality = 0.57;
      } else if (fileSizeMB > 10) {
        // Large originals: aggressive compression
        quality = 0.65;
      } else {
        // Medium originals: moderate compression
        quality = 0.75;
      }

      // Convert blob to File for imageCompression
      const file = new File([blob], "thumbnail.webp", { type: "image/webp" });

      const compressedFile = await imageCompression(file, {
        maxSizeMB: fileSizeMB > 20 ? 0.025 : 0.05, // Balanced limit (25KB) between 20KB and 30KB
        maxWidthOrHeight: 300, // Maintain 300px dimension
        useWebWorker: false,
        fileType: "image/webp",
        initialQuality: quality,
      });

      return compressedFile;
    } catch {
      // If optimization fails, return original blob
      return blob;
    }
  }

  /**
   * Upload blob to S3 using presigned URL
   */
  private async uploadToS3(presignedUrl: string, blob: Blob, contentType: string): Promise<void> {
    const response = await fetch(presignedUrl, {
      method: "PUT",
      body: blob,
      headers: {
        "Content-Type": contentType,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to upload to S3: ${response.status} ${response.statusText}`);
    }
  }

  /**
   * Generate preview (1400px) from image using browser-image-compression
   * For full-screen quality viewing on desktop, 8K TV, and high-resolution displays
   *
   * Uses adaptive quality based on original file size to better hit target file size ranges
   * while maintaining quality priority for client selection.
   *
   * browser-image-compression is better than raw Canvas API because:
   * - Handles EXIF orientation automatically
   * - Better memory management
   * - Handles edge cases (very large images, etc.)
   * - Simpler API
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async generatePreview(file: any, maxWidthOrHeight: number = 1400): Promise<Blob | null> {
    const fileWithMeta = file as UppyFileWithMeta;
    if (!fileWithMeta.data || !(fileWithMeta.data instanceof File)) {
      return null;
    }

    try {
      // Calculate adaptive quality based on original file size
      const fileSizeMB = fileWithMeta.data.size / (1024 * 1024);
      const quality = this.calculateAdaptiveQuality(fileSizeMB, "preview");

      // Use browser-image-compression to generate 1400px preview
      // Optimized for full-screen quality viewing:
      // - 1400px: Perfect for desktop, 8K TV, and high-resolution displays
      // - Adaptive quality (0.88-0.92): Adjusts based on original size to hit target
      //   Target: ~0.8-1.2MB per preview
      // - Maintains aspect ratio (not square like thumbnail)
      const compressedFile = await imageCompression(fileWithMeta.data, {
        maxSizeMB: 5, // Reasonable limit for 1400px preview
        maxWidthOrHeight, // Fit inside 1400px, maintain aspect ratio
        useWebWorker: false, // Simpler, works everywhere
        fileType: "image/webp", // Convert to WebP
        initialQuality: quality, // Adaptive quality - excellent for professional review
      });

      return compressedFile;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Generate BigThumb (600px) from image using browser-image-compression
   * For masonry/responsive grid layouts in client gallery
   *
   * Uses adaptive quality based on original file size to better hit target file size ranges
   * while maintaining quality priority for client selection.
   *
   * This provides a middle tier between thumbnail and preview:
   * - Perfect for beautiful gallery layouts
   * - Maintains aspect ratio (not square like thumbnail)
   * - Optimized for all connection speeds
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private async generateBigThumb(file: any, maxWidthOrHeight: number = 600): Promise<Blob | null> {
    const fileWithMeta = file as UppyFileWithMeta;
    if (!fileWithMeta.data || !(fileWithMeta.data instanceof File)) {
      return null;
    }

    try {
      // Calculate adaptive quality based on original file size
      const fileSizeMB = fileWithMeta.data.size / (1024 * 1024);
      const quality = this.calculateAdaptiveQuality(fileSizeMB, "bigthumb");

      // Use browser-image-compression to generate 600px BigThumb
      // Optimized for masonry/responsive grid layouts:
      // - 600px: Perfect for gallery grid views on all devices
      // - Adaptive quality (0.75-0.90): Adjusts based on original size to hit target
      //   Target: ~80-120KB per BigThumb
      // - Maintains aspect ratio (not square like thumbnail)
      // - Fast loading even on 4G mobile connections
      const compressedFile = await imageCompression(fileWithMeta.data, {
        maxSizeMB: fileSizeMB > 20 ? 0.16 : 2, // Balanced limit (160KB) between 150KB and 180KB
        maxWidthOrHeight, // Fit inside 600px, maintain aspect ratio
        useWebWorker: false, // Simpler, works everywhere
        fileType: "image/webp", // Convert to WebP
        initialQuality: quality, // Adaptive quality - perfect balance for gallery viewing
      });

      return compressedFile;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Convert image blob to WebP format (fallback if thumbnail is not WebP)
   * Uses browser-image-compression for reliable conversion
   */
  private async convertToWebP(
    blob: Blob,
    maxWidthOrHeight: number,
    quality: number
  ): Promise<Blob> {
    try {
      // Convert blob to File for imageCompression
      const file = new File([blob], "image.jpg", { type: blob.type });

      const compressedFile = await imageCompression(file, {
        maxSizeMB: 10,
        maxWidthOrHeight,
        useWebWorker: false,
        fileType: "image/webp",
        initialQuality: quality,
      });

      return compressedFile;
    } catch (_error) {
      return blob; // Fallback to original
    }
  }
}
