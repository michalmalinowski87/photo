import { BasePlugin, type UppyFile } from "@uppy/core";
import imageCompression from "browser-image-compression";

/**
 * Custom Uppy plugin to upload thumbnails and previews to S3
 * 
 * This plugin:
 * 1. Uses Uppy's ThumbnailGenerator for 200px thumbnail (via thumbnail:generated event)
 * 2. Generates preview (1200px) using browser-image-compression library
 * 3. Converts to WebP format
 * 4. Uploads to S3 using presigned URLs
 * 
 * Why this approach:
 * - Uppy's ThumbnailGenerator: Best for 200px thumbnail (uses Canvas API internally, optimized)
 * - browser-image-compression: Better than raw Canvas API for 1200px preview (simpler, more reliable)
 * - Both use Canvas API under the hood, but these libraries handle edge cases better
 */
export class ThumbnailUploadPlugin extends BasePlugin {
  static VERSION = "1.0.0";

  constructor(uppy: any, opts: any) {
    super(uppy, opts);
    this.id = "thumbnail-upload";
    this.type = "modifier";
  }

  install() {
    // Listen for thumbnail generation event from Uppy's ThumbnailGenerator
    // We don't need to access the plugin directly - just listen to its events
    this.uppy.on("thumbnail:generated", this.handleThumbnailGenerated.bind(this));
    
    // Also listen for upload completion to upload preview (1200px) and ensure thumbnail is uploaded
    this.uppy.on("upload-success", this.handleUploadSuccess.bind(this));
  }

  uninstall() {
    this.uppy.off("thumbnail:generated", this.handleThumbnailGenerated);
    this.uppy.off("upload-success", this.handleUploadSuccess);
  }

  /**
   * Handle when Uppy's ThumbnailGenerator creates a thumbnail
   * This gives us the 200px thumbnail that we can use directly
   * Event signature: thumbnail:generated(file, preview)
   */
  private handleThumbnailGenerated(file: UppyFile, preview: string) {
    // Store the generated thumbnail preview URL for later use
    // The preview is a data URL (e.g., "data:image/webp;base64,...")
    if (!file.meta) {
      file.meta = {};
    }
    file.meta.thumbnailPreview = preview;
    
    // eslint-disable-next-line no-console
    console.log("[ThumbnailUpload] Thumbnail generated by Uppy:", file.name, "Type:", preview.substring(5, preview.indexOf(";")));
  }

  private async handleUploadSuccess(file: UppyFile) {
    // Only process image files
    if (!file.type?.startsWith("image/")) {
      return;
    }

    // Get presigned URLs from file metadata (set during getUploadParameters)
    const presignedData = file.meta?.presignedData as {
      previewUrl?: string;
      thumbnailUrl?: string;
    } | undefined;

    if (!presignedData?.previewUrl || !presignedData?.thumbnailUrl) {
      // eslint-disable-next-line no-console
      console.warn("[ThumbnailUpload] No presigned URLs found in file metadata");
      return;
    }

    try {
      // Generate preview (1200px) - Uppy's ThumbnailGenerator only does 200px
      const preview = await this.generatePreview(file);
      
      // Get thumbnail from Uppy's ThumbnailGenerator (200px, already generated)
      const thumbnailBlob = await this.getThumbnailBlob(file);

      if (!preview || !thumbnailBlob) {
        // eslint-disable-next-line no-console
        console.warn("[ThumbnailUpload] Failed to generate preview/thumbnail for file:", file.name);
        return;
      }

      // Upload preview and thumbnail to S3
      await Promise.all([
        this.uploadToS3(presignedData.previewUrl, preview, "image/webp"),
        this.uploadToS3(presignedData.thumbnailUrl, thumbnailBlob, "image/webp"),
      ]);

      // eslint-disable-next-line no-console
      console.log("[ThumbnailUpload] Successfully uploaded thumbnails for:", file.name);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("[ThumbnailUpload] Failed to upload thumbnails:", error);
      // Don't fail the upload if thumbnail upload fails
    }
  }

  /**
   * Get the thumbnail blob from Uppy's generated thumbnail
   * The thumbnail was generated by ThumbnailGenerator and stored in file.preview
   * Since we configured thumbnailType: 'image/webp', it should already be WebP
   */
  private async getThumbnailBlob(file: UppyFile): Promise<Blob | null> {
    try {
      // Uppy's ThumbnailGenerator stores the thumbnail in file.preview (data URL)
      // The preview property contains the data URL of the generated thumbnail
      const thumbnailPreview = file.preview || file.meta?.thumbnailPreview;
      
      if (!thumbnailPreview) {
        // eslint-disable-next-line no-console
        console.warn("[ThumbnailUpload] No thumbnail preview found for file:", file.name);
        return null;
      }

      // Convert data URL to blob
      // Data URL format: data:image/webp;base64,...
      const response = await fetch(thumbnailPreview);
      const blob = await response.blob();
      
      // Since we configured thumbnailType: 'image/webp', it should already be WebP
      // But verify and convert if needed
      if (blob.type === "image/webp") {
        return blob;
      }
      
      // If not WebP, convert it (shouldn't happen with our config, but just in case)
      // eslint-disable-next-line no-console
      console.warn("[ThumbnailUpload] Thumbnail is not WebP, converting:", blob.type);
      return await this.convertToWebP(blob, 200, 0.8);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("[ThumbnailUpload] Failed to get thumbnail blob:", error);
      return null;
    }
  }

  /**
   * Upload blob to S3 using presigned URL
   */
  private async uploadToS3(presignedUrl: string, blob: Blob, contentType: string): Promise<void> {
    const response = await fetch(presignedUrl, {
      method: "PUT",
      body: blob,
      headers: {
        "Content-Type": contentType,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to upload to S3: ${response.status} ${response.statusText}`);
    }
  }

  /**
   * Generate preview (1200px) from image using browser-image-compression
   * Thumbnail (200px) is generated by Uppy's ThumbnailGenerator
   * 
   * browser-image-compression is better than raw Canvas API because:
   * - Handles EXIF orientation automatically
   * - Better memory management
   * - Handles edge cases (very large images, etc.)
   * - Simpler API
   */
  private async generatePreview(
    file: UppyFile
  ): Promise<Blob | null> {
    if (!file.data || !(file.data instanceof File)) {
      return null;
    }

    try {
      // Use browser-image-compression to generate 1200px preview
      // maxSizeMB: 10 (large enough for preview)
      // maxWidthOrHeight: 1200 (fit inside, maintain aspect ratio)
      // useWebWorker: false (simpler, works in all browsers)
      // fileType: 'image/webp' (convert to WebP)
      const compressedFile = await imageCompression(file.data as File, {
        maxSizeMB: 10, // Large enough for 1200px preview
        maxWidthOrHeight: 1200, // Fit inside 1200px, maintain aspect ratio
        useWebWorker: false, // Simpler, works everywhere
        fileType: "image/webp", // Convert to WebP
        initialQuality: 0.85, // WebP quality
      });

      return compressedFile;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("[ThumbnailUpload] Failed to generate preview:", error);
      return null;
    }
  }

  /**
   * Convert image blob to WebP format (fallback if thumbnail is not WebP)
   * Uses browser-image-compression for reliable conversion
   */
  private async convertToWebP(
    blob: Blob,
    maxWidthOrHeight: number,
    quality: number
  ): Promise<Blob> {
    try {
      // Convert blob to File for imageCompression
      const file = new File([blob], "image.jpg", { type: blob.type });
      
      const compressedFile = await imageCompression(file, {
        maxSizeMB: 10,
        maxWidthOrHeight,
        useWebWorker: false,
        fileType: "image/webp",
        initialQuality: quality,
      });
      
      return compressedFile;
    } catch (error) {
      // eslint-disable-next-line no-console
      console.warn("[ThumbnailUpload] Failed to convert to WebP, returning original:", error);
      return blob; // Fallback to original
    }
  }
}

