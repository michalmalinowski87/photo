# CloudFront Signed URLs Setup for ZIP Downloads

This guide explains how to set up CloudFront signed URLs for secure ZIP downloads. CloudFront provides faster downloads via edge locations and signed URLs ensure only authorized users can download ZIP files.

For large orders (100+ images), ZIP generation uses a chunked flow with parallel workers. See [zip-generation-architecture.md](zip-generation-architecture.md) for details.

## Quick Start

**Automated Setup (Recommended):**
```bash
```bash
# 1. Generate key pair locally:
./scripts/generate-cloudfront-keypair.sh

# 2. Copy the public key and paste it in CloudFront Console (see Step 1 below)
#    - View public key: cat cloudfront-public-key-*.pem
#    - Copy entire content (including BEGIN/END lines)
#    - Paste in CloudFront console
#    - Note the Public Key ID shown after creating the public key

# 3. Run the setup script with your private key and Public Key ID:
./scripts/setup-cloudfront-keys.sh <stage> <public-key-id> cloudfront-private-key-*.pem

# Example:
./scripts/setup-cloudfront-keys.sh dev K1234567890ABC cloudfront-private-key-20250130-143022.pem
```
```

**Manual Setup:**
Follow the detailed steps below.

## Prerequisites

- AWS CLI configured with appropriate permissions
- Access to AWS Console (CloudFront, SSM Parameter Store)
- Your deployment stage (e.g., `dev`, `prod`)

## Step 1: Create CloudFront Public Key and Get Key Pair ID

CloudFront uses **public keys** (not key pairs) for signed URLs. When you create a public key, CloudFront returns a **Public Key ID** which you'll use as the `Key-Pair-Id` parameter in signed URLs.

**Important**: You need to generate the key pair locally first, then upload the public key to CloudFront.

### Step 1a: Generate Key Pair Locally

**Option 1: Use the helper script (Recommended)**
```bash
# Generate key pair using the helper script
./scripts/generate-cloudfront-keypair.sh

# This will create:
# - cloudfront-private-key-{timestamp}.pem
# - cloudfront-public-key-{timestamp}.pem
```

**Option 2: Generate manually**
```bash
# Generate a 2048-bit RSA private key
# Note: OpenSSL won't show output if successful - this is normal!
# The file will be created in your current directory
openssl genrsa -out cloudfront-private-key.pem 2048

# Verify the file was created (check your current directory)
ls -lh cloudfront-private-key.pem
# You should see: -rw------- 1 user group 1675 Jan 30 14:30 cloudfront-private-key.pem

# Extract the public key from the private key
openssl rsa -in cloudfront-private-key.pem -pubout -out cloudfront-public-key.pem

# Verify the public key was created
ls -lh cloudfront-public-key.pem
# You should see: -rw-r--r-- 1 user group 451 Jan 30 14:30 cloudfront-public-key.pem
```

**Note**: If you don't see any output from OpenSSL commands, that's normal! OpenSSL only outputs errors. Check that the files were created with `ls -lh`.

### Step 1b: Upload Public Key to CloudFront

1. **Open AWS CloudFront Console**
   - Navigate to: https://console.aws.amazon.com/cloudfront/v3/home#/public-key
   - Or: AWS Console → CloudFront → Public keys → Create public key

2. **Create Public Key**
   - Click "Create public key"
   - **Key name**: `PhotoCloud-{stage}-ZIP-Downloads` (e.g., `PhotoCloud-dev-ZIP-Downloads`)
   - **Key value**: 
     - Open the public key file (`cloudfront-public-key.pem` or the file generated by the script)
     - Copy its **entire contents**, including the BEGIN and END lines:
       ```
       -----BEGIN PUBLIC KEY-----
       MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
       (entire key content - multiple lines)
       -----END PUBLIC KEY-----
       ```
     - Paste it into the "Key value" text area in CloudFront console
     - ⚠️ **Important**: Make sure you copy ALL lines, including `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`
   - **Comment** (optional): `Public key for signed URLs - ZIP downloads - {stage}`
   - Click "Create public key" (or "Add" button)

3. **Record the Public Key ID**
   - After creating the public key, CloudFront will display the **Public Key ID**
   - This ID looks like: `K1234567890ABC` or `APKAIOSFODNN7EXAMPLE`
   - **IMPORTANT**: Copy and save this ID - you'll need it for Step 2
   - This Public Key ID is what you'll use as the `Key-Pair-Id` parameter in signed URLs

**Note**: You already have the private key file (`cloudfront-private-key.pem` or the timestamped file from the script). Keep it secure - you'll use it in Step 2.

**Troubleshooting**: If you see an error about invalid key format:
- Make sure you copied the entire public key including BEGIN/END lines
- Verify the key is in PEM format (not DER or other formats)
- Check that there are no extra spaces or line breaks at the beginning/end
- Try viewing the file: `cat cloudfront-public-key.pem` to see the exact content

### Step 1c: Create Key Group and Add to CloudFront Distribution

**IMPORTANT**: You must create a Key Group and add it to your CloudFront distribution's cache behavior for ZIP files. This ensures CloudFront requires signed URLs for ZIP downloads.

1. **Create Key Group**
   - Navigate to: https://console.aws.amazon.com/cloudfront/v3/home#/key-groups
   - Click "Create key group"
   - **Key group name**: `PhotoCloud-{stage}-ZIP-KeyGroup` (e.g., `PhotoCloud-dev-ZIP-KeyGroup`)
   - **Public keys**: Select the public key you created in Step 1b
   - Click "Create key group"
   - **Note the Key Group ID** (you'll need this for the cache behavior)

2. **Add Cache Behaviors to CloudFront Distribution**

   You need to add **TWO** cache behaviors - one for original ZIPs and one for final ZIPs:

   **Behavior 1: Original ZIPs**
   - Navigate to your CloudFront distribution in AWS Console
   - Go to the **Behaviors** tab
   - Click **Create behavior**
   - **Path pattern**: `galleries/*/zips/*` (matches original ZIP files: `galleries/{galleryId}/zips/{orderId}.zip`)
   - **Origin and origin groups**: Select your S3 bucket origin
   - **Viewer protocol policy**: Redirect HTTP to HTTPS
   - **Allowed HTTP methods**: GET, HEAD, OPTIONS
   - **Cache policy**: Choose a policy (or create one for ZIP files)
   - **Restrict viewer access**: **Yes** (this is critical!)
   - **Trusted key groups**: Select the key group you created above
   - **Trusted signers**: Leave empty (we're using key groups, not signers)
   - Click **Create behavior**

   **Behavior 2: Final ZIPs**
   - Click **Create behavior** again
   - **Path pattern**: `galleries/*/orders/*/final-zip/*` (matches final ZIP files: `galleries/{galleryId}/orders/{orderId}/final-zip/{filename}`)
   - **Origin and origin groups**: Select your S3 bucket origin
   - **Viewer protocol policy**: Redirect HTTP to HTTPS
   - **Allowed HTTP methods**: GET, HEAD, OPTIONS
   - **Cache policy**: Choose a policy (or create one for ZIP files)
   - **Restrict viewer access**: **Yes** (this is critical!)
   - **Trusted key groups**: Select the same key group you created above
   - **Trusted signers**: Leave empty (we're using key groups, not signers)
   - Click **Create behavior**

3. **Verify Behavior Order**
   - CloudFront processes behaviors in order (most specific first)
   - Ensure both behaviors appear **before** the default `*` behavior:
     1. `galleries/*/orders/*/final-zip/*` (most specific - final ZIPs)
     2. `galleries/*/zips/*` (original ZIPs)
     3. `*` (default - images)
   - If needed, use the **Move up** button to reorder

**Why this is important**: Without this cache behavior requiring signed URLs, CloudFront will serve ZIP files without validating signatures, which can cause conflicts when browsers include AWS credentials from previous requests.

## Step 2: Store Configuration in SSM Parameter Store

Now that you have:
- ✅ Private key file (`cloudfront-private-key.pem`)
- ✅ Public Key ID from CloudFront (e.g., `K1234567890ABC`)

You need to store these in AWS Systems Manager (SSM) Parameter Store so your Lambda functions can access them.

### Get Your Stage

Determine your deployment stage (usually `dev` or `prod`). This is used in the SSM parameter paths.

### Store Private Key (SecureString)

```bash
# Replace {stage} with your actual stage (e.g., dev, prod)
# Replace {path-to-private-key.pem} with the actual path to your downloaded private key file

aws ssm put-parameter \
  --name "/PhotoHub/{stage}/CloudFrontPrivateKey" \
  --type "SecureString" \
  --value "$(cat {path-to-private-key.pem})" \
  --description "CloudFront private key for signed URLs (ZIP downloads) - {stage}" \
  --overwrite
```

**Example for dev:**
```bash
aws ssm put-parameter \
  --name "/PhotoHub/dev/CloudFrontPrivateKey" \
  --type "SecureString" \
  --value "$(cat ~/Downloads/pk-APKAIOSFODNN7EXAMPLE.pem)" \
  --description "CloudFront private key for signed URLs (ZIP downloads) - dev" \
  --overwrite
```

### Store Public Key ID (String)

```bash
# Replace {stage} with your actual stage
# Replace {PUBLIC_KEY_ID} with the Public Key ID from CloudFront console (e.g., K1234567890ABC)
# Note: This is the ID shown after creating the public key in CloudFront

aws ssm put-parameter \
  --name "/PhotoHub/{stage}/CloudFrontKeyPairId" \
  --type "String" \
  --value "{PUBLIC_KEY_ID}" \
  --description "CloudFront public key ID (used as Key-Pair-Id) for signed URLs (ZIP downloads) - {stage}" \
  --overwrite
```

**Example for dev:**
```bash
aws ssm put-parameter \
  --name "/PhotoHub/dev/CloudFrontKeyPairId" \
  --type "String" \
  --value "K1234567890ABC" \
  --description "CloudFront public key ID (used as Key-Pair-Id) for signed URLs (ZIP downloads) - dev" \
  --overwrite
```

**Note**: The parameter name is `CloudFrontKeyPairId` for historical reasons, but it stores the Public Key ID from CloudFront.

## Step 3: Update CDK Stack (Optional)

If you want to update the placeholder in CDK, you can modify `infra/lib/app-stack.ts`:

```typescript
const cloudfrontKeyPairIdParam = new StringParameter(this, 'CloudFrontKeyPairIdParam', {
  parameterName: `${ssmParameterPrefix}/CloudFrontKeyPairId`,
  stringValue: 'YOUR_ACTUAL_PUBLIC_KEY_ID', // Replace PLACEHOLDER with Public Key ID from CloudFront
  description: 'CloudFront public key ID (used as Key-Pair-Id) for signed URLs (ZIP downloads).'
});
```

**Note**: This is optional - the SSM parameter can be set manually without updating CDK. The parameter name `CloudFrontKeyPairId` is used for compatibility, but it stores the Public Key ID from CloudFront.

## Step 4: Verify Configuration

### Check SSM Parameters

```bash
# Verify private key exists (will show parameter name, not the value for security)
aws ssm describe-parameters \
  --parameter-filters "Key=Name,Values=/PhotoHub/{stage}/CloudFrontPrivateKey"

# Verify key pair ID exists
aws ssm get-parameter \
  --name "/PhotoHub/{stage}/CloudFrontKeyPairId" \
  --query "Parameter.Value" \
  --output text
```

### Test ZIP Download

After deploying your Lambda functions, test a ZIP download:
1. Generate a ZIP file for an order
2. Wait for ZIP to be ready
3. Attempt to download the ZIP
4. Verify it downloads successfully from CloudFront

## Step 5: Verify CloudFront Distribution Configuration

The CloudFront distribution should already be configured via CDK. Verify:

1. **Distribution exists**: Check CloudFront console
2. **Origin Access Control (OAC)**: Should be configured automatically
3. **Bucket policy**: Should allow CloudFront access
4. **Cache behaviors for ZIP files**: 
   - Must have **TWO** behaviors:
     - `galleries/*/zips/*` (for original ZIPs)
     - `galleries/*/orders/*/final-zip/*` (for final ZIPs)
   - Both must have "Restrict viewer access" set to **Yes**
   - Both must have your Key Group selected in "Trusted key groups"
   - Both must appear **before** the default `*` behavior in the behaviors list
   - Order should be: final-zip pattern first, then zips pattern, then default

If the distribution doesn't exist or isn't configured correctly, redeploy your CDK stack. **However, the cache behavior for ZIP files with signed URLs must be added manually** (see Step 1c above) as CDK doesn't automatically create Key Groups.

## Troubleshooting

### Error: "Only one auth mechanism allowed" (S3 error)

**Cause**: Request is going directly to S3 instead of CloudFront, or CloudFront cache behavior doesn't require signed URLs.

**Solutions**:
1. **Verify cache behaviors exist**: Check CloudFront console → Behaviors tab
   - Look for **TWO** behaviors:
     - `galleries/*/zips/*` (for original ZIPs)
     - `galleries/*/orders/*/final-zip/*` (for final ZIPs)
   - Both must have "Restrict viewer access" set to **Yes**
   - Both must have your Key Group selected in "Trusted key groups**

2. **Check behavior order**: Both ZIP behaviors must appear **before** the default `*` behavior
   - CloudFront matches behaviors in order (most specific first)
   - Order should be:
     1. `galleries/*/orders/*/final-zip/*` (most specific)
     2. `galleries/*/zips/*`
     3. `*` (default)
   - If `*` comes first, ZIP requests will use the default behavior (which doesn't require signed URLs)

3. **Verify the path matches**: Check which ZIP type you're downloading
   - Original ZIPs: `galleries/{galleryId}/zips/{orderId}.zip` → needs `galleries/*/zips/*` behavior
   - Final ZIPs: `galleries/{galleryId}/orders/{orderId}/final-zip/{filename}` → needs `galleries/*/orders/*/final-zip/*` behavior

3. **Verify CloudFront URL**: Check that the URL in the error starts with your CloudFront domain (e.g., `d1234.cloudfront.net`), not S3 (e.g., `bucket.s3.amazonaws.com`)

4. **Clear browser cache**: Old requests might be cached. Try:
   - Hard refresh (Ctrl+Shift+R or Cmd+Shift+R)
   - Incognito/private browsing mode
   - Clear browser cache and cookies

### Error: "CloudFront configuration missing"

**Cause**: SSM parameters are not set or Lambda doesn't have permission to read them.

**Solutions**:
1. Verify SSM parameters exist:
   ```bash
   aws ssm get-parameter --name "/PhotoHub/{stage}/CloudFrontPrivateKey" --with-decryption
   aws ssm get-parameter --name "/PhotoHub/{stage}/CloudFrontKeyPairId"
   ```

2. Verify Lambda IAM role has SSM permissions:
   - Check that Lambda execution role includes: `ssm:GetParameter`, `ssm:GetParameters`
   - Check parameter ARN is in the policy: `arn:aws:ssm:{region}:{account}:parameter/PhotoHub/{stage}/*`

3. Verify stage matches your deployment:
   - Check `STAGE` environment variable in Lambda
   - Ensure SSM parameter paths match: `/PhotoHub/{stage}/...`

### Error: "ZIP not found" when ZIP exists in S3

**Cause**: ZIP hasn't propagated to CloudFront yet, or CloudFront cache needs invalidation.

**Solutions**:
1. Wait a few minutes for CloudFront propagation (usually < 5 minutes)
2. Invalidate CloudFront cache for the ZIP path:
   ```bash
   aws cloudfront create-invalidation \
     --distribution-id {DISTRIBUTION_ID} \
     --paths "/galleries/{galleryId}/orders/{orderId}/final-zip/*"
   ```

### Error: "Invalid signature" when downloading

**Cause**: Private key doesn't match the public key configured in CloudFront, or Public Key ID is incorrect.

**Solutions**:
1. Verify Public Key ID matches the one shown in CloudFront console (Public keys section)
2. Verify private key matches the public key you uploaded (they must be from the same key pair)
3. If you regenerated keys, make sure you uploaded the NEW public key to CloudFront
4. Check that the public key is added to a key group and the key group is associated with your CloudFront distribution's cache behavior

## Security Best Practices

1. **Private Key Storage**:
   - Never commit private keys to git
   - Store only in SSM Parameter Store as SecureString
   - Rotate keys periodically (annually recommended)

2. **Access Control**:
   - Limit SSM parameter access to Lambda execution roles only
   - Use IAM policies to restrict parameter access
   - Monitor CloudWatch logs for unauthorized access attempts

3. **Key Rotation**:
   - Create new key pair before expiration
   - Update SSM parameters with new values
   - Update CloudFront distribution to use new public key
   - Old signed URLs will stop working after rotation

## Architecture

```
User Request → API Gateway → Lambda (downloadFinalZip/downloadZip)
                                    ↓
                            Check CloudFront path exists
                                    ↓
                            Generate CloudFront signed URL
                                    ↓
                            User downloads from CloudFront edge
```

## Benefits

- **Faster Downloads**: CloudFront edge locations provide 2-5x faster downloads
- **Better Reliability**: CDN caching and edge distribution
- **Security**: Signed URLs ensure only authorized users can download
- **Cost Effective**: CloudFront data transfer is often cheaper than S3 direct transfer

## Related Files

- `backend/functions/orders/downloadFinalZip.ts` - Final ZIP download handler
- `backend/functions/orders/downloadZip.ts` - Original ZIP download handler
- `backend/lib/src/cloudfront-signer.ts` - CloudFront signed URL generation utility
- `infra/lib/app-stack.ts` - CDK infrastructure (CloudFront distribution setup)
